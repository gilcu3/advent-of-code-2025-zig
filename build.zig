const std = @import("std");

pub fn build(b: *std.Build) !void {
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});

    const run_all = b.step("run", "Run all days");
    const bench_all = b.step("bench", "Benchmark all days");
    const test_all = b.step("test", "Test all days");

    var last_run_step: ?*std.Build.Step = null;

    const day_option = b.option(usize, "ay", "Day");
    const update_readme = b.option(bool, "readme", "Update README.md");

    var day_files = std.ArrayList([]const u8).init(b.allocator);

    for (1..26) |day| {
        const day_zig_file_str = b.fmt("src/days/day{d:0>2}.zig", .{day});
        const day_zig_file = b.path(day_zig_file_str);
        if (std.fs.cwd().access(day_zig_file_str, .{ .mode = .read_only }) == error.FileNotFound) {
            continue;
        }

        const run_exe = b.addExecutable(.{
            .name = b.fmt("run-day{d:0>2}", .{day}),
            .root_source_file = b.path("src/run.zig"),
            .target = target,
            .optimize = .ReleaseFast,
        });
        run_exe.root_module.addAnonymousImport("day", .{ .root_source_file = day_zig_file });
        b.installArtifact(run_exe);

        const unit_test = b.addTest(.{ .root_source_file = day_zig_file, .target = target });

        if (day_option == null or day_option == day) {
            const run_cmd = b.addRunArtifact(run_exe);
            if (last_run_step) |last| {
                run_cmd.step.dependOn(last);
            }
            last_run_step = &run_cmd.step;

            try day_files.append(day_zig_file_str);

            const test_cmd = b.addRunArtifact(unit_test);
            test_all.dependOn(&test_cmd.step);
        }
    }
    if (last_run_step) |last| run_all.dependOn(last);

    const manifest_path = "zig-out/manifest.zig";
    generateManifestNow(day_files, manifest_path) catch @panic("Failed to write manifest");

    const bench_exe = b.addExecutable(.{
        .name = "benchmark_runner",
        .root_source_file = b.path("src/bench.zig"),
        .target = target,
        .optimize = .ReleaseFast,
    });

    const manifest_module = b.createModule(.{
        .root_source_file = b.path(manifest_path),
    });

    for (day_files.items) |file_path| {
        const name = std.fs.path.stem(file_path);

        const day_module = b.createModule(.{
            .root_source_file = b.path(file_path),
        });

        manifest_module.addImport(name, day_module);
    }

    bench_exe.root_module.addImport("manifest", manifest_module);

    for (day_files.items) |file_path| {
        const name = std.fs.path.stem(file_path);
        const day_module = b.createModule(.{
            .root_source_file = b.path(file_path),
        });
        bench_exe.root_module.addImport(name, day_module);
    }

    const bench_cmd = b.addRunArtifact(bench_exe);

    if (update_readme == true) {
        const output_file = bench_cmd.captureStdOut();

        const update_tool = b.addRunArtifact(b.addExecutable(.{
            .name = "update_readme",
            .root_source_file = b.path("src/update_readme.zig"),
            .target = target,
            .optimize = optimize,
        }));

        update_tool.addFileArg(output_file);

        update_tool.step.dependOn(&bench_cmd.step);

        bench_all.dependOn(&update_tool.step);
    } else {
        bench_all.dependOn(&bench_cmd.step);
    }
}

fn generateManifestNow(files: std.ArrayList([]const u8), out_path: []const u8) !void {
    const file = try std.fs.cwd().createFile(out_path, .{});
    defer file.close();
    var writer = file.writer();

    try writer.writeAll("// Auto-generated by build.zig\n");

    for (files.items) |f| {
        const name = std.fs.path.stem(f);
        try writer.print("pub const {s} = @import(\"{s}\");\n", .{ name, name });
    }

    try writer.writeAll("\npub const modules = .{\n");
    for (files.items) |f| {
        const name = std.fs.path.stem(f);
        try writer.print("    .{{ .name = \"{s}\", .m = {s} }},\n", .{ name, name });
    }
    try writer.writeAll("};\n");
}
